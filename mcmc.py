"""
    the mcmc method for a 2 parameter fitting problem
"""

import random
import numpy as np


class Walker(object):
    """
    the mcmc walker
    """

    def __init__(self, pars_range, likelihood_func,
                 begin_step=500, burn_step=100,
                 random_initial=True, initial_pars=None,
                 global_step=False, step_box_length=None):

        self.pars_range = pars_range
        self.likelihood_func = likelihood_func

        if random_initial:
            self.initial_pars =  \
                [random.uniform(par_range[0], par_range[1])
                 for par_range in pars_range]
        else:
            self.initial_pars = initial_pars

        # parameters/likelihoods on the Markov Chain
        self.pars_on_chain = [self.initial_pars]
        self.likelihoods_on_chain = [likelihood_func(self.initial_pars)]

        # the current step
        self.current_pars = self.initial_pars

        # boolean indicating if the chain is burned
        self.burned = False

        # boolean indicating the step select method,
        # if global_step, next step will be chosen uniformly
        # randomly from the pars_range box,
        # if not global_step, a sized box centered at current step
        # is used to select next step Guassianly within it.
        self.global_step = global_step
        self.step_box_length = step_box_length

        # number of steps from begining of the chain
        self.begin_step = begin_step

        # number of steps after burned
        self.burn_step = burn_step

    def add_new_step(self, new_pars, new_likelihood):
        """
        add new step to the chain
        """
        self.current_pars = new_pars
        self.pars_on_chain.append(new_pars)
        self.likelihoods_on_chain.append(new_likelihood)

    def step_select_method(self):
        """
        if global_step, next step will be chosen uniformly randomly
        from the pars_range box,
        if not global_step, a sized box centered at current step
        is used to select next step gaussian randomly within it.
        """
        if self.global_step:
            return [random.uniform(par_range[0], par_range[1])
                    for par_range in self.pars_range]
        else:
            return [random.gauss(current_par, length)
                    for current_par, length in
                    zip(self.current_pars, self.step_box_length)]

    def step_accept_method(self):
        """
        standing at the current step, given a new
        step candidate generated by self.step_select_method,
        return if accept the candidate step
        using following to achieve detailed balance:
        if candicate_pars exceed pars_range: decline (return False)
        if likelihood(current) < likelihood(candidate): accept (add candidate and return True)
        if likelihood(current) > likelihood(candidate):
        accept at a possibility of likelihood(candidate)/likelihood(current) or decline
        """
        candidate_pars = self.step_select_method()
        # any par exceed the pars_range, decline
        if any([(candidate_par > par_range[1]) | (candidate_par < par_range[0])
                for candidate_par, par_range in zip(candidate_pars, self.pars_range)]):
            return False

        # get the likelihood of both current and candidate pars for comparison
        current_l = self.likelihoods_on_chain[-1]
        candidate_l = self.likelihood_func(candidate_pars)

        if current_l < candidate_l:
            self.add_new_step(candidate_pars, candidate_l)
        else:
            # simulate the "possibility"
            if random.uniform(0, 1) < np.exp(candidate_l-current_l):
                self.add_new_step(candidate_pars, candidate_l)
                return True
            else:
                return False

    def begin_walk(self):
        """
        begin walking from initial
        """
        print "begin walking..."
        total_iter = 0
        for nn in range(self.begin_step):
            # if not finding an acceptable new step, keep finding
            niter = 1
            while not self.step_accept_method():
                # if self.step_accept_method returns true,
                # chain is already updated by it, so nothing to do here
                niter += 1
                #print "bad"
                continue
            #print "good"
            total_iter = total_iter+niter
        print "efficiency: step %d processed over %d iterations"%(self.begin_step, total_iter)
        return self.pars_on_chain, self.likelihoods_on_chain

